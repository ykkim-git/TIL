# 13장 동시성

> 동시성과 깔끔한 코드는 양립하기 어렵다. 스레드를 하나만 실행하는 코드는 짜기 쉽고, 겉으로 보기에는
> 깔끔하지만 깊숙한 곳에 문제가 있는 다중 스레드 코드도 짜기 쉽다. 이 챕터에서는 여러 스레드를 동시에 돌리는 이유와 어려움을 논한다.

- 참고로 자바스크립트는 메인 쓰레드인 이벤트 루프가 싱글 쓰레드이기 때문에 자바스크립트를 싱글 쓰레드 언어라고 부른다.
  (`alert`이 실행되면 경고창에서 확인을 누르기 전까진 UI 조작이 불가하고. 혹은 그 이후 코드도 실행되지 않는 걸 알 수 있는 것 처럼)

## 동시성이 필요한 이유

동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다.

무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다. 구조적인 관점에서 프로그램은 거대한 루프 하나가 아닌 작은 협력 프로그램 여럿으로 보인다. 따라서 시스템 이해가 쉽고 문제 분리도 쉽다.

### 미신과 오해

미신

- ~~동시성은 항상 성능을 높여준다.~~
  - **동시성은 때때로 성능을 높여준다**
- ~~동시성을 구현해도 설계는 변하지 않는다.~~
  - **일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.**
- ~~웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.~~
  - **실제로는 컨테이너가 어떻게 동작하는지, 동시수정, 데드락과 같은 문제를 피할 수 있는지 알아야 한다.**

## 동시성을 구현하며 맞이하는 난관

동시성을 구현하기 어려운 몇가지 이유를 알아보면,

### 동시성 방어 원칙

- 첫번째 단일 책임 원칙

주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.

동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하기 때문이다.

- 자료 범위를 제한하라

공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라고 권장한다.

**_임계영역: 동시 사용을 막아야만 프로그램이 올바로 동작하는 보호받는 코드 영역_**

공유 자료를 수정하는 위치가 많을수록

1. 보호할 임계영역을 빼먹는다.
2. 모든 임계영역을 올바로 보호했는지 확인하느라 시간을 허비한다.
3. 버그를 찾아내기가 더 어려워진다.

- 자료 사본을 사용하자

공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다.

공유 객체를 피하는 방법이 있다면 코드가 문제를 일으킬 가능성도 낮아진다.

- 스레드는 가능한 독립적으로 구현하라

다른 스레드와 자료를 공유하지 않는다. 각 스레드는 클라이언트 요청 하나를 처리하고, 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.

### 실행 모델을 이해하라

다중 스레드 어플리케이션을 분류하는 방식에 사용되는 기본 용어들부터 알아보자면

- 한정된 자원: 크기나 숫자가 제한적 (ex: 읽기/쓰기 버퍼)
- 상호 배제: 한 번에 한 스레드만 공유자료나 공유자원 사용
- 기아: 스레드가 영원히 자원을 기다림
- 데드락: 여러 스레드가 서로가 끝나기를 기다림.
- 라이브락: 락을 거는 단계에서 각 스레드가 서로를 방해함

다중 스레드 프로그래밍에서 사용하는 실행 모델들

- 생산자-소비자

하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다. 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.

- 읽기-쓰기

읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만, 쓰기 스레드가 공유 자원을 갱신한다면

처리율이 문제의 핵심이다. 처리율을 강조하면 기아 현상이 생기거고, 갱신을 허용하면 처리율에 영향을 미친다.

스레드가 버퍼를 갱신하는 동안 읽기/쓰기 버퍼를 읽지 않으려면 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법을 사용한다.

### 동기화하는 메서드 사이에 의존성이 존재하면

동시에 찾아내기 어려운 버그가 생긴다. 그리고 공유 객체 하나에 여러 메서드가 필요한 상황도 생긴다.

그럴 때는 다음 세 가지 방법을 고려한다.

- 클라이언트에서 잠금: 첫 번째 메서드 호출 전 서버를 잠근다. (마지막 메서드 호출 때 까지)
- 서버에서 잠금: "서버를 잠그고 모든 메서드 호출 후 잠금을 해제"하는 메서드 구현
- 연결 서버: 잠금을 수행하는 중간 단계를 생성한다.

### 동기화하는 부분을 작게 만들어라

자바에서 synchronized 키워드를 사용하면 락을 설정한다.

락은 스레드를 지연시키고 부하를 가중시키므로 synchronized 문을 남발하지 않는다.

임계영역은 반드시 보호해야 한다. 코드를 짤 때는 임계영역 수를 최대한 줄여야 한다.

### 올바른 종료 코드는 구현하기 어렵다.

종료코드를 짜며 가장 흔히 발생하는 문제가 데드락이다.

만약 부모 스레드가 자식 스레드를 여러 개 만든 후 모두가 끝나기를 기다렸다가 자원을 해제하고

종료하는 시스템일때, 자식 스레드 중 하나가 데드락에 걸렸다면 부모 스레드는 영원히 기다리고,

시스템은 영원히 종료되지 못한다. 그러므로 종료 코드는 개발 초기부터 고민하자.

## 스레드 코드 테스트하기

코드가 올바르다고 증명하기는 현실적으로 불가능하다. 테스트가 정확성을 보장하진 않지만

충분한 테스트는 위험을 낮춘다.

- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라

다중 스레드 코드는 때때로 '말이 안 되는' 오류를 일으킨다. 그러므로 시스템 실패를 일회성이라 치부하지 말자

- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

스레드 환경 밖에서 생기는 버그와 안에서 생기는 버그를 동시에 디버깅하지 말자.

- 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하자

적절한 스레드 개수를 파악하려면 시행착오가 필요하니 처음부터 다양한 설정으로 성능 측정 방법을 강구하자

그 외에 방법으로는

- 프로세서 수보다 많은 스레드를 돌려보기
- 여러 다른 플랫폼에서 돌려보기
- 코드에 보조코드를 넣어 돌려서 강제로 실패를 일으키게 하기가 있다.

> 코드를 짜면서 어떻게든 문제는 생길텐데, 초반에 문제가 드러나지 않았다고 해서 일회성 문제라고 생각했었는데 이 챕터를 보며 일회성 문제는 보통 시스템에 부하가 걸릴 때나 뜬금없이 발생한다고 해서 띵 하고 머리를 한 대 맞은 것 같았다. 다시 한 번 테스트의 중요성을 깨닫게 되었다.
