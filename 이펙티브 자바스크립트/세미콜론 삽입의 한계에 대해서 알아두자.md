## 세미콜론 삽입의 한계에 대해서 알아두자

> 자바스크립트의 편리함 중 하나는 문장을 종료하는 세미콜론을 생략할 수 있다는 점이다.
> 하지만, 암묵적인 강제 형변환과 비슷하게 세미콜론 삽입에는 함정이 있다.

### 세미콜론은 한 줄 이상의 새로운 행이나,

프로그램 입력의 마지막이나 } 토큰 전에만 삽입된다.

아래 코드는 문제가 없는 코드이지만

```jsx
function square(x) {
  var n = x;
  return n * n;
}
function area(r) {
  r = r;
  return Math.PI * r;
}
```

이 코드는 잘못된 예이다.

```jsx
function area(r) { r = r return Math.PI * r }   // 에러
```

프로그램의 마지막인 부분에만 생략이 가능한데 r = r;로 프로그램의 마지막을
알리지 않았기 때문에 에러가 나온다.

### 세미콜론은 다음 입력 토큰을 파싱할 수 없을 때에만 삽입된다.

다섯 개의 조심해야하는 문자가 있다.

- (
- [
- -
- -
- /

문맥에 따라 표현식 연산자로 동작하거나 선언의 접두어로 사용될 수 있기 때문이다.

아래와 같은 코드가 있다면.

```jsx
a = b[("a", "b", "c")].forEach((key) => {
  console.log(key);
});
```

아래와 같이 파싱된다.

```jsx
a = b[("a", "b", "c")].forEach((key) => {
  console.log(key);
});
```

그리고 또 조심해야 할 경우로 return 인데, return 키워드와 그 자신의 부가적인 인자 사이에
새로운 행이 포함되지 않아야 한다.

이 코드는 새로운 객체를 리턴하지만

```jsx
return {};
```

이 코드는 디르게 파싱된다.

```jsx
return;
{
}
```

```jsx
return;
{
}
```

결론적으로 return 키워드 다음에 오는 새로운 행은 자동 세미콜론 삽입을 강제한다.

### 세미콜론은 for 반복문의 구분자나 빈 선언문으로 절대 삽입되지 않는다.

> 즉, for 루프의 머리 부분에 반드시 명시적으로 세미콜론을 포함해야 한다는 것!

```jsx
for (var i = 0, i > n, i++) {
	i = i + 1;
} // Error

for (var i = 0; i > n; i++) {
	// Pass
}
```
